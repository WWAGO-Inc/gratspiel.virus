document.addEventListener('DOMContentLoaded', () => {
    const board = document.getElementById('board');
    const result = document.getElementById('result');
    const resetBtn = document.getElementById('reset');
    const difficultySelect = document.getElementById('difficulty');
  
    let currentPlayer = 'X';
    let boardState = ['', '', '', '', '', '', '', '', ''];
    let gameOver = false;
  
    // Draw the game board
    function drawBoard() {
      board.innerHTML = '';
      boardState.forEach((cell, index) => {
        const cellElement = document.createElement('div');
        cellElement.classList.add('cell');
        cellElement.innerText = cell;
        cellElement.addEventListener('click', () => cellClick(index));
        board.appendChild(cellElement);
      });
    }
  
    // Handle click on cell
    function cellClick(index) {
      if (!gameOver && boardState[index] === '') {
        boardState[index] = currentPlayer;
        drawBoard();
        checkWinner();
        if (!gameOver) {
          currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
          if (currentPlayer === 'O') {
            setTimeout(makeAIMove, 500); // AI move delay
          }
        }
      }
    }
  
    // Check for a winner or tie
    function checkWinner() {
      const winningCombos = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
      ];
  
      for (const combo of winningCombos) {
        const [a, b, c] = combo;
        if (boardState[a] && boardState[a] === boardState[b] && boardState[a] === boardState[c]) {
          gameOver = true;
          result.innerText = `${boardState[a]} hat gewonnen!`;
          return;
        }
      }
  
      if (!boardState.includes('')) {
        gameOver = true;
        result.innerText = 'Unentschieden!';
      }
    }
  
    // Reset the game
    function resetGame() {
      currentPlayer = 'X';
      boardState = ['', '', '', '', '', '', '', '', ''];
      gameOver = false;
      drawBoard();
      result.innerText = '';
    }
  
    // AI makes a move
    function makeAIMove() {
      const difficulty = parseInt(difficultySelect.value);
      const availableMoves = boardState.reduce((acc, cell, index) => {
        if (cell === '') acc.push(index);
        return acc;
      }, []);
  
      // Make a random move if difficulty is set to 1
      if (difficulty === 1) {
        const randomIndex = Math.floor(Math.random() * availableMoves.length);
        cellClick(availableMoves[randomIndex]);
      } else {
        const bestMove = minimax(boardState, currentPlayer, difficulty).index;
        cellClick(bestMove);
      }
    }
  
    // Minimax algorithm with alpha-beta pruning
    function minimax(newBoard, player, depth, alpha = -Infinity, beta = Infinity) {
      const availableMoves = newBoard.reduce((acc, cell, index) => {
        if (cell === '') acc.push(index);
        return acc;
      }, []);
  
      if (checkWinnerForPlayer('X', newBoard)) {
        return { score: -10 };
      } else if (checkWinnerForPlayer('O', newBoard)) {
        return { score: 10 };
      } else if (availableMoves.length === 0) {
        return { score: 0 };
      }
  
      const moves = [];
      for (const move of availableMoves) {
        const newBoardState = [...newBoard];
        newBoardState[move] = player;
  
        const nextPlayer = player === 'X' ? 'O' : 'X';
        const moveScore = minimax(newBoardState, nextPlayer, depth - 1, alpha, beta).score;
        newBoardState[move] = '';
  
        moves.push({ index: move, score: moveScore });
  
        if (player === 'O') {
          if (moveScore > alpha) alpha = moveScore;
        } else {
          if (moveScore < beta) beta = moveScore;
        }
  
        if (alpha >= beta) break;
      }
  
      return player === 'O' ? maxScore(moves) : minScore(moves);
    }
  
    function maxScore(moves) {
      let bestScore = -Infinity;
      let bestMove;
      for (const move of moves) {
        if (move.score > bestScore) {
          bestScore = move.score;
          bestMove = move;
        }
      }
      return bestMove;
    }
  
    function minScore(moves) {
      let bestScore = Infinity;
      let bestMove;
      for (const move of moves) {
        if (move.score < bestScore) {
          bestScore = move.score;
          bestMove = move;
        }
      }
      return bestMove;
    }
  
    // Check if a player has won
    function checkWinnerForPlayer(player, newBoard) {
      const winningCombos = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
      ];
  
      for (const combo of winningCombos) {
        const [a, b, c] = combo;
        if (newBoard[a] === player && newBoard[a] === newBoard[b] && newBoard[a] === newBoard[c]) {
          return true;
        }
      }
      return false;
    }
  
    // Initialize the game
    drawBoard();
    resetBtn.addEventListener('click', resetGame);
  });
  